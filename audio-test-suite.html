<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Audio Test Suite - Hume EVI</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      body {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        padding: 20px;
      }
      .container {
        max-width: 1200px;
        margin: 0 auto;
        background: white;
        border-radius: 12px;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
        overflow: hidden;
      }
      .header {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 30px;
        text-align: center;
      }
      .header h1 {
        font-size: 2em;
        margin-bottom: 10px;
      }
      .header p {
        opacity: 0.9;
      }
      .content {
        padding: 30px;
      }
      .test-section {
        background: #f9f9f9;
        border-radius: 8px;
        padding: 20px;
        margin-bottom: 20px;
        border-left: 4px solid #667eea;
      }
      .test-section h2 {
        color: #333;
        margin-bottom: 15px;
        display: flex;
        align-items: center;
        gap: 10px;
      }
      .btn {
        background: #667eea;
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 16px;
        font-weight: 600;
        transition: all 0.3s;
        margin: 5px;
      }
      .btn:hover {
        background: #5568d3;
        transform: translateY(-2px);
      }
      .btn:disabled {
        background: #ccc;
        cursor: not-allowed;
        transform: none;
      }
      .btn-danger {
        background: #f44336;
      }
      .btn-danger:hover {
        background: #da190b;
      }
      .btn-success {
        background: #4caf50;
      }
      .btn-success:hover {
        background: #45a049;
      }
      .log {
        background: #1e1e1e;
        color: #d4d4d4;
        padding: 20px;
        border-radius: 6px;
        max-height: 400px;
        overflow-y: auto;
        font-family: 'Courier New', monospace;
        font-size: 13px;
        line-height: 1.6;
        margin-top: 15px;
      }
      .log-entry {
        margin: 5px 0;
      }
      .log-success {
        color: #4caf50;
      }
      .log-error {
        color: #f44336;
      }
      .log-warning {
        color: #ff9800;
      }
      .log-info {
        color: #2196f3;
      }
      .stats {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 15px;
        margin: 20px 0;
      }
      .stat-card {
        background: white;
        padding: 20px;
        border-radius: 8px;
        border: 2px solid #e0e0e0;
        text-align: center;
      }
      .stat-value {
        font-size: 2.5em;
        font-weight: bold;
        color: #667eea;
        margin: 10px 0;
      }
      .stat-label {
        color: #666;
        font-size: 0.9em;
      }
      .recording-indicator {
        display: inline-block;
        width: 12px;
        height: 12px;
        background: #f44336;
        border-radius: 50%;
        animation: pulse 1.5s infinite;
      }
      @keyframes pulse {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.3;
        }
      }
      .file-input {
        margin: 15px 0;
        padding: 15px;
        background: white;
        border-radius: 6px;
        border: 2px dashed #ccc;
      }
      input[type='file'] {
        width: 100%;
      }
      .controls {
        margin: 20px 0;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1>üéôÔ∏è Audio Test Suite - Hume EVI</h1>
        <p>Complete testing environment for debugging audio transcription</p>
      </div>

      <div class="content">
        <!-- Test 1: Record Audio -->
        <div class="test-section">
          <h2><span>1Ô∏è‚É£</span> Record Test Audio</h2>
          <p>Record audio samples directly in the browser</p>
          <div class="controls">
            <button id="recordBtn" class="btn" onclick="startRecording()">
              üé§ Start Recording
            </button>
            <button id="stopBtn" class="btn btn-danger" onclick="stopRecording()" disabled>
              ‚èπÔ∏è Stop Recording
            </button>
            <button id="playBtn" class="btn" onclick="playRecording()" disabled>
              ‚ñ∂Ô∏è Play Last Recording
            </button>
            <button id="downloadBtn" class="btn btn-success" onclick="downloadRecording()" disabled>
              üíæ Download
            </button>
          </div>
          <div id="recordingsList"></div>
        </div>

        <!-- Test 2: Upload & Verify -->
        <div class="test-section">
          <h2><span>2Ô∏è‚É£</span> Upload & Verify Audio Files</h2>
          <p>Upload WebM files to verify they're valid</p>
          <div class="file-input">
            <input
              type="file"
              id="uploadFiles"
              accept="audio/webm,audio/ogg"
              multiple
              onchange="verifyFiles()"
            />
          </div>
          <div id="filesList"></div>
        </div>

        <!-- Test 3: Test with Hume -->
        <div class="test-section">
          <h2><span>3Ô∏è‚É£</span> Test with Hume EVI</h2>
          <p>Send audio to Hume and monitor responses</p>
          <div class="controls">
            <button class="btn" onclick="testFullFile()">üì§ Send Full File (No Chunking)</button>
            <button class="btn" onclick="testChunked(100)">üì¶ Send Chunked (100ms)</button>
            <button class="btn" onclick="testChunked(500)">üì¶ Send Chunked (500ms)</button>
            <button class="btn btn-danger" onclick="disconnectHume()">üîå Disconnect</button>
          </div>
        </div>

        <!-- Statistics -->
        <div class="stats">
          <div class="stat-card">
            <div class="stat-label">User Messages</div>
            <div class="stat-value" id="userMsgCount">0</div>
          </div>
          <div class="stat-card">
            <div class="stat-label">Assistant Messages</div>
            <div class="stat-value" id="assistantMsgCount">0</div>
          </div>
          <div class="stat-card">
            <div class="stat-label">Errors</div>
            <div class="stat-value" id="errorCount">0</div>
          </div>
          <div class="stat-card">
            <div class="stat-label">Connection Status</div>
            <div class="stat-value" id="connectionStatus" style="font-size: 1.2em">‚ùå</div>
          </div>
        </div>

        <!-- Live Log -->
        <div class="test-section">
          <h2><span>üìã</span> Live Debug Log</h2>
          <button class="btn" onclick="clearLog()">üóëÔ∏è Clear Log</button>
          <button class="btn" onclick="exportLog()">üíæ Export Log</button>
          <div id="log" class="log"></div>
        </div>
      </div>
    </div>

    <script>
      // Global state
      let mediaRecorder = null;
      let audioChunks = [];
      let recordings = [];
      let currentRecordingBlob = null;
      let humeWs = null;
      let uploadedFiles = [];
      let stats = { userMessages: 0, assistantMessages: 0, errors: 0 };

      // Logging
      function log(message, type = 'info') {
        const logDiv = document.getElementById('log');
        const timestamp = new Date().toLocaleTimeString();
        const className = `log-${type}`;
        const entry = `<div class="log-entry ${className}">[${timestamp}] ${message}</div>`;
        logDiv.innerHTML += entry;
        logDiv.scrollTop = logDiv.scrollHeight;
      }

      function clearLog() {
        document.getElementById('log').innerHTML = '';
        stats = { userMessages: 0, assistantMessages: 0, errors: 0 };
        updateStats();
      }

      function exportLog() {
        const logContent = document.getElementById('log').innerText;
        const blob = new Blob([logContent], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `hume-test-log-${Date.now()}.txt`;
        a.click();
      }

      function updateStats() {
        document.getElementById('userMsgCount').textContent = stats.userMessages;
        document.getElementById('assistantMsgCount').textContent = stats.assistantMessages;
        document.getElementById('errorCount').textContent = stats.errors;
      }

      // Recording functions
      async function startRecording() {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });
          audioChunks = [];

          mediaRecorder.ondataavailable = (event) => {
            audioChunks.push(event.data);
          };

          mediaRecorder.onstop = () => {
            const blob = new Blob(audioChunks, { type: 'audio/webm' });
            currentRecordingBlob = blob;
            recordings.push({ blob, timestamp: Date.now() });

            document.getElementById('playBtn').disabled = false;
            document.getElementById('downloadBtn').disabled = false;

            log(`‚úÖ Recording saved (${(blob.size / 1024).toFixed(2)} KB)`, 'success');
            updateRecordingsList();
          };

          mediaRecorder.start();
          document.getElementById('recordBtn').disabled = true;
          document.getElementById('stopBtn').disabled = false;
          log('üé§ Recording started...', 'info');
        } catch (error) {
          log(`‚ùå Error starting recording: ${error.message}`, 'error');
        }
      }

      function stopRecording() {
        if (mediaRecorder && mediaRecorder.state !== 'inactive') {
          mediaRecorder.stop();
          mediaRecorder.stream.getTracks().forEach((track) => track.stop());
          document.getElementById('recordBtn').disabled = false;
          document.getElementById('stopBtn').disabled = true;
          log('‚èπÔ∏è Recording stopped', 'info');
        }
      }

      function playRecording() {
        if (currentRecordingBlob) {
          const audio = new Audio(URL.createObjectURL(currentRecordingBlob));
          audio.play();
          log('‚ñ∂Ô∏è Playing recording...', 'info');
        }
      }

      function downloadRecording() {
        if (currentRecordingBlob) {
          const url = URL.createObjectURL(currentRecordingBlob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `test-audio-${Date.now()}.webm`;
          a.click();
          log(`üíæ Downloaded: ${a.download}`, 'success');
        }
      }

      function updateRecordingsList() {
        const list = document.getElementById('recordingsList');
        list.innerHTML = `<p>Total recordings: ${recordings.length}</p>`;
      }

      // File verification
      async function verifyFiles() {
        const files = document.getElementById('uploadFiles').files;
        uploadedFiles = Array.from(files);
        const listDiv = document.getElementById('filesList');
        listDiv.innerHTML = '';

        log(`üìÅ Verifying ${files.length} file(s)...`, 'info');

        for (let file of files) {
          const result = await verifyAudioFile(file);
          listDiv.innerHTML += result;
        }
      }

      async function verifyAudioFile(file) {
        return new Promise((resolve) => {
          const audio = new Audio();
          const url = URL.createObjectURL(file);
          audio.src = url;

          audio.onloadedmetadata = () => {
            const duration = audio.duration;
            log(
              `‚úÖ ${file.name}: ${duration.toFixed(2)}s, ${(file.size / 1024).toFixed(2)} KB`,
              'success'
            );
            resolve(`
            <div style="background: #e8f5e9; padding: 10px; margin: 5px 0; border-radius: 4px;">
              <strong>${file.name}</strong><br>
              Duration: ${duration.toFixed(2)}s | Size: ${(file.size / 1024).toFixed(2)} KB<br>
              <audio controls src="${url}" style="width: 100%; margin-top: 5px;"></audio>
            </div>
          `);
          };

          audio.onerror = () => {
            log(`‚ùå ${file.name}: Invalid audio file`, 'error');
            resolve(`
            <div style="background: #ffebee; padding: 10px; margin: 5px 0; border-radius: 4px;">
              <strong>${file.name}</strong> - ‚ùå Invalid audio file
            </div>
          `);
          };
        });
      }

      // Hume WebSocket functions
      function connectToHume() {
        return new Promise((resolve, reject) => {
          if (humeWs && humeWs.readyState === WebSocket.OPEN) {
            resolve(humeWs);
            return;
          }

          log('üîå Connecting to Hume...', 'info');
          humeWs = new WebSocket('ws://localhost:3000/api/hume/ws?userId=audio-test');

          humeWs.onopen = () => {
            log('‚úÖ Connected to Hume EVI', 'success');
            document.getElementById('connectionStatus').textContent = '‚úÖ';
            resolve(humeWs);
          };

          humeWs.onmessage = (event) => {
            try {
              const data = JSON.parse(event.data);
              handleHumeMessage(data);
            } catch (e) {
              // Binary data
              log('üì• Received binary audio data', 'info');
            }
          };

          humeWs.onerror = (error) => {
            log('‚ùå WebSocket error', 'error');
            document.getElementById('connectionStatus').textContent = '‚ùå';
            stats.errors++;
            updateStats();
            reject(error);
          };

          humeWs.onclose = () => {
            log('üîå Disconnected from Hume', 'warning');
            document.getElementById('connectionStatus').textContent = '‚ùå';
            humeWs = null;
          };
        });
      }

      function handleHumeMessage(data) {
        log(`üì• ${data.type}`, 'info');

        if (data.type === 'user_message') {
          stats.userMessages++;
          log(`üé§ USER SAID: "${data.message.content}"`, 'success');
          updateStats();
        } else if (data.type === 'assistant_message') {
          stats.assistantMessages++;
          log(`ü§ñ ASSISTANT: "${data.message.content}"`, 'info');
          updateStats();
        } else if (data.type === 'error') {
          stats.errors++;
          log(`‚ùå ERROR [${data.code}]: ${data.message}`, 'error');
          updateStats();
        } else if (data.type === 'user_interruption') {
          log('‚ö†Ô∏è User interrupted assistant', 'warning');
        }
      }

      function disconnectHume() {
        if (humeWs) {
          humeWs.close();
          humeWs = null;
          log('üîå Manually disconnected', 'warning');
        }
      }

      // Test methods
      async function testFullFile() {
        const file = uploadedFiles[0] || currentRecordingBlob;
        if (!file) {
          log('‚ùå No audio file available. Record or upload first!', 'error');
          return;
        }

        try {
          const ws = await connectToHume();
          log('üì§ Sending FULL file (no chunking)...', 'info');

          const arrayBuffer =
            file instanceof Blob ? await file.arrayBuffer() : await file.arrayBuffer();

          const reader = new FileReader();
          reader.onloadend = () => {
            const base64 = reader.result.split(',')[1];

            const message = {
              type: 'audio_input',
              data: base64,
            };

            ws.send(JSON.stringify(message));
            log(`‚úÖ Sent ${(base64.length / 1024).toFixed(2)} KB as single message`, 'success');
          };

          const blob = file instanceof Blob ? file : new Blob([arrayBuffer]);
          reader.readAsDataURL(blob);
        } catch (error) {
          log(`‚ùå Error: ${error.message}`, 'error');
        }
      }

      async function testChunked(chunkDurationMs) {
        const file = uploadedFiles[0] || currentRecordingBlob;
        if (!file) {
          log('‚ùå No audio file available. Record or upload first!', 'error');
          return;
        }

        try {
          const ws = await connectToHume();
          log(`üì¶ Sending file in ${chunkDurationMs}ms chunks...`, 'info');

          const arrayBuffer =
            file instanceof Blob ? await file.arrayBuffer() : await file.arrayBuffer();

          const reader = new FileReader();
          reader.onloadend = () => {
            const base64 = reader.result.split(',')[1];
            const chunkSize = Math.ceil(base64.length / (10000 / chunkDurationMs)); // Approximate

            let offset = 0;
            let chunkCount = 0;

            const sendChunk = () => {
              if (offset >= base64.length) {
                log(`‚úÖ Sent ${chunkCount} chunks`, 'success');
                return;
              }

              const chunk = base64.substring(offset, offset + chunkSize);
              const message = {
                type: 'audio_input',
                data: chunk,
              };

              ws.send(JSON.stringify(message));
              chunkCount++;
              offset += chunkSize;

              setTimeout(sendChunk, chunkDurationMs);
            };

            sendChunk();
          };

          const blob = file instanceof Blob ? file : new Blob([arrayBuffer]);
          reader.readAsDataURL(blob);
        } catch (error) {
          log(`‚ùå Error: ${error.message}`, 'error');
        }
      }

      // Initialize
      log('üöÄ Audio Test Suite Ready', 'success');
      log('üìù Instructions:', 'info');
      log('1. Record audio OR upload WebM files', 'info');
      log('2. Verify files are valid', 'info');
      log('3. Test with different sending methods', 'info');
      log('4. Watch for USER SAID messages (transcriptions)', 'info');
    </script>
  </body>
</html>
